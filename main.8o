 

# some psuedo-16 registers
:alias a16_hi v2
:alias a16_lo v3

:alias b16_hi v4
:alias b16_lo v5

:alias c16_hi v6
:alias c16_lo v7

:macro unpack_to_r16 r16_hi r16_lo address {
	:calc HI_VALUE { ( address & 0xFF00 ) >> 8 }
	:calc LO_VALUE { address & 0xFF }
	r16_hi := HI_VALUE
	r16_lo := LO_VALUE
}

:macro set_r16 dest_hi dest_lo src_hi src_lo {
	dest_hi := src_hi
	dest_lo := src_lo
}

#######################################################################
# Combination generation and storage
#######################################################################

:alias current_digit_index vB
:alias current_digit_value vC

# storage for the hidden code and its value
:const SIZE_DIGIT_ARRAY 	 4
:const SIZE_MEMBERSHIP_TABLE 2
:calc  SIZE_CODE_STRUCTURE   { SIZE_DIGIT_ARRAY + SIZE_MEMBERSHIP_TABLE }

:const DIGIT_MIN 0
:const DIGIT_MAX 9
:calc  DIGIT_BASE { DIGIT_MAX + 1 }

: membership_masks
	# bit mask for digit values 0 - 9
	# these are used because all digits must be
	# unique in this game rather than have a count
	# like in word games.

	0x00 0x01 # 0
	0x00 0x02 # 1
	0x00 0x04 # 2
	0x00 0x08 # 3
	0x00 0x10 # 4
	0x00 0x20 # 5
	0x00 0x40 # 6
	0x00 0x80 # 7
	0x01 0x00 # 8
	0x02 0x00 # 9


: get_mask_for_digit 
	# assumes: vC / current_digit_value is used as storage for current_value
	# assumes: c16_hi , c16 lo used for constant return storage
	i := membership_masks

	# double the digit because the table is full of 16 bit ints
	vD := current_digit_value
	vD <<= vD

	# load the mask to the constant registers
	i += vD
	load c16_hi - c16_lo

return


: hidden_code
	
	: hidden_code_value
		0x00 0x00 0x00 0x00

	# binary table of which digits the lock combination uses
	: hidden_code_membership 		
		0x00 0x00

	# the hidden code will always match itself
	: hidden_code_valid
		0x00
	: hidden_code_in_pos
		0x04
	: hidden_code_in_seq
		0x00

: chosen_code

	: chosen_code_value 
		0x00 0x00 0x00 0x00

	# binary table of which digits the user guess tried 
	: chosen_code_membership 
		0x00 0x00

	# these will need to be updated by calculations, some against the hidden combo
	: chosen_code_valid
		0x00
	: chosen_code_in_pos
		0x00
	: chosen_code_in_seq
		0x00

: comparison_data
	0x00 # how many are 
	0x00

# monitor the structures above
:monitor hidden_code_value "hidden value: %i %i %i %i" 
:monitor hidden_code_membership "hidden membership: %b %b"
:monitor chosen_code_value "chosen value: %i %i %i %i"
:monitor chosen_code_membership "chosen membership: %b %b"
:monitor chosen_code_in_pos "chosen grade: %d %d"
:monitor chosen_code_valid "chosen validity: %x"

: gen_single_unique_digit
	# assumes: b16_hi and b16_lo are up to date with current state info
	# assumes: vB is used as current_digit_value

	: _try_generate_digit

		# inefficient & biased PRNG equivalent to randint(0,256) % 10,
		# if you're a beginner reading this source, there are likely
		# better ways to do RNG for your specific game.

		current_digit_value := random 0xFF
		loop
			if current_digit_value >= DIGIT_BASE begin
				current_digit_value -= DIGIT_BASE
				again	
			end

		# copy mask value into a16
		get_mask_for_digit
		set_r16 a16_hi a16_lo c16_hi c16_lo	

		# check for intersection with current used mask
		a16_hi &= b16_hi
		a16_lo &= b16_lo

		a16_hi |= a16_lo # compact into a single variable for easier checking

		if a16_hi != 0 then jump _try_generate_digit

return

# shorten offsetting from i when we don't care about vF
:macro i_offset CONSTANT OFFSET {
	i := CONSTANT
	vF := OFFSET
	i += vF
}


: genenerate_hidden_combo

	current_digit_index := 0
	b16_hi := 0x00 b16_lo := 0x00 # clear membership

	loop

		gen_single_unique_digit

		# store the actual digit in memory
		i_offset hidden_code_value current_digit_index
		save current_digit_value - current_digit_value

		# update membership table
		b16_hi |= c16_hi
		b16_lo |= c16_lo

		# advance to next digit
		current_digit_index += 1


		while current_digit_index < SIZE_DIGIT_ARRAY
	again

	i := hidden_code_membership
	save b16_hi - b16_lo
return

: validate_chosen_and_calculate_mask

	current_digit_index := 0
	# reset the membership masks
	b16_hi := 0 b16_lo := 0

	loop

		# load the mask for the current digit
		i_offset chosen_code_value current_digit_index
		load current_digit_value - current_digit_value
		get_mask_for_digit

		# mark as invalid if any digits repeated
		vF := b16_hi
		vF &= c16_hi
		if vF != 0 then jump _invalidate_chosen
		vF := b16_lo
		vF &= c16_lo
		if vF != 0 then jump _invalidate_chosen

		# update the table
		b16_hi |= c16_hi
		b16_lo |= c16_lo

		# loop until we've covered the size of the array
		current_digit_index += 1
		while current_digit_index < SIZE_DIGIT_ARRAY
	again

	: _validate_chosen
		i := chosen_code_membership
		save b16_hi - b16_lo
		vF := 1
		jump _validate_end

	: _invalidate_chosen
		# don't bother trying to save membership for invalid array
		vf := 0

	: _validate_end
		i := chosen_code_valid
		save vF - vF
return

: calculate_number_matched
return


#######################################################################
# Column rendering 
#######################################################################

:const GRID_TILE_WIDTH   9
:const GRID_TILE_HEIGHT  9

:const GRID_START_LEFT   9
:const GRID_START_TOP    9

:const CHAR_HEIGHT       5
:const CHAR_WIDTH        3

# Space around characters in grid. 
# Tip: match odd and even character dimensions to tile dimensions
:calc  GRID_PADDING_Y   { ( GRID_TILE_HEIGHT - CHAR_HEIGHT ) / 2  }
:calc  GRID_PADDING_X   { ( GRID_TILE_WIDTH - CHAR_WIDTH ) / 2 }

# which tile position the characters will actually start in
:calc  GRID_START_CHARS_TOP { GRID_START_TOP + GRID_TILE_HEIGHT }

# where the characters in the grid will actually start in pixel x and y
:calc  GRID_CHAR_START_Y     { GRID_START_CHARS_TOP + GRID_PADDING_Y }
:calc  GRID_CHAR_START_X     { GRID_START_LEFT + GRID_PADDING_X }


:alias draw_x v0
:alias draw_y v1


: font_3x5
	# A 3x5 font to ensure that text is always rendered as intended.
	#
	# Note that not all interpreters use the same font.	
	# Based on https://robey.lag.net/2010/01/23/tiny-monospace-font.html 
	# 
	# Each of the characters is padded to 8 bytes for easier addressing.
	# If we use even number lengths, finding the correct index is only
	# a matter of bit shifting left three times instead of implementing 
	# a slow multiply routine.

	: digit_0
		0x60 0xA0 0xA0 0xA0 0xC0 0x00 0x00 0x00

	: digit_1
		0x40 0xC0 0x40 0x40 0xE0 0x00 0x00 0x00

	: digit_2
		0xC0 0x20 0x40 0x80 0xE0 0x00 0x00 0x00	

	: digit_3
		0xC0 0x20 0x40 0x20 0xC0 0x00 0x00 0x00

	: digit_4
		0xA0 0xA0 0xE0 0x20 0x20 0x00 0x00 0x00	

	: digit_5
		0xE0 0x80 0xC0 0x20 0xC0 0x00 0x00 0x00	

	: digit_6
		0x60 0x80 0xE0 0xA0 0xE0 0x00 0x00 0x00	

	: digit_7
		0xE0 0x20 0x40 0x80 0x80 0x00 0x00 0x00	

	: digit_8
		0xE0 0xA0 0xE0 0xA0 0xE0 0x00 0x00 0x00

	: digit_9
		0xE0 0xA0 0xE0 0x20 0xC0 0x00 0x00 0x00	


: square_1x1
	0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00

: square_3x3
	0xE0 0xE0 0xE0 0x00 0x00 0x00 0x00 0x00

: square_7x7
	0xFE 0xFE 0xFE 0xFE 0xFE 0xFE 0xFE 0x00


# the position after the grid tiles
:calc  COLUMN_SIZE_Y        { SIZE_DIGIT_ARRAY * GRID_TILE_HEIGHT }

:const INDICATOR_SIDE_LENGTH 3
:calc  INDICATOR_MARGIN_Y { ( GRID_TILE_HEIGHT - ( 2 * INDICATOR_SIDE_LENGTH ) ) / 3 }
:calc  INDICATOR_MARGIN_X { ( GRID_TILE_WIDTH  - ( 2 * INDICATOR_SIDE_LENGTH ) ) / 3 }
:calc  INDICATOR_STEP_Y   { INDICATOR_MARGIN_X + INDICATOR_SIDE_LENGTH }
:calc  INDICATOR_STEP_X   { INDICATOR_MARGIN_Y + INDICATOR_SIDE_LENGTH }


:calc SQUARE_OFFSET_Y_START { GRID_TILE_HEIGHT - INDICATOR_MARGIN_Y }
:calc SQUARE_OFFSET_X { INDICATOR_MARGIN_X }
:calc SQUARE_OFFSET_Y_UNDO { SQUARE_OFFSET_Y_START - INDICATOR_STEP_Y }

: draw_square
	# takes a draw_x, draw_y argument, and thrashes them a bit

	# align to grid 
	draw_y -= SQUARE_OFFSET_Y_START # Goes up, 9 - 1
	draw_x += INDICATOR_MARGIN_X

	i := square_3x3

	# top left
	sprite draw_x draw_y 3

	# top right
	draw_x += INDICATOR_STEP_X
	sprite draw_x draw_y 3

	# bottom right
	draw_y += INDICATOR_STEP_Y
	sprite draw_x draw_y 3

	draw_x -= INDICATOR_STEP_X
	sprite draw_x draw_y 3

	# return to original position
	draw_y += SQUARE_OFFSET_Y_UNDO
	draw_x -= INDICATOR_MARGIN_X

return

: load_current_digit_value

	: _load_current_digit_value_long_i_set_opcode
		0xF0 0x00
	# this destination address will be rewritten by a subsequent helper	
	: _load_current_digit_value_long_i_set_address
		0x00 0x00
	#:monitor _load_current_digit_value_long_i_set_address "%x %x"
	i += current_digit_index
	load current_digit_value - current_digit_value

return


: set_combo_currently_rendering
	i := _load_current_digit_value_long_i_set_address
	save c16_hi - c16_lo	
return

:macro select_combo_to_render COMBO_ADDRESS {
	unpack_to_r16 c16_hi c16_lo COMBO_ADDRESS
	set_combo_currently_rendering
}
# helpers to go back to the original address
:calc UNDO_COMBO_OFFSET_X { GRID_PADDING_X }
:calc UNDO_COMBO_OFFSET_Y { GRID_PADDING_Y + COLUMN_SIZE_Y }

: draw_selected_combo
	# takes draw_x, draw_y as arguments

	draw_x += GRID_PADDING_X
	draw_y += GRID_PADDING_Y

	current_digit_index := 0
	loop

		load_current_digit_value

		# set i to font_3x5 + (current_digit_value * 8)
		i := font_3x5
		current_digit_value <<= current_digit_value
		current_digit_value <<= current_digit_value
		current_digit_value <<= current_digit_value	
		i += current_digit_value

		# draw the chosen digit 
		sprite draw_x draw_y CHAR_HEIGHT
		draw_y += GRID_TILE_HEIGHT

		current_digit_index += 1
		while current_digit_index < SIZE_DIGIT_ARRAY
	again
	# return to the original position for the column
	draw_x -= UNDO_COMBO_OFFSET_X
	draw_y -= UNDO_COMBO_OFFSET_Y
return


# todo: make this a stack?
# stop worrying about registers, just cache draw position in memory 
: stored_draw_position
	0x00 0x00

: save_draw_position
	i := stored_draw_position
	save draw_y
return

: load_draw_position
	i := stored_draw_position
	load draw_y
return


# input constants
:const TUMBLER_0_DECREMENT OCTO_KEY_1
:const TUMBLER_0_INCREMENT OCTO_KEY_2
:const TUMBLER_1_DECREMENT OCTO_KEY_Q
:const TUMBLER_1_INCREMENT OCTO_KEY_W
:const TUMBLER_2_DECREMENT OCTO_KEY_A
:const TUMBLER_2_INCREMENT OCTO_KEY_S
:const TUMBLER_3_DECREMENT OCTO_KEY_Z
:const TUMBLER_3_INCREMENT OCTO_KEY_X


:const SUBMIT_KEY OCTO_KEY_F
:const INCREMENT  1
:const DECREMENT  2
:const SUBMIT     3


# shorthand for jumping to a label at the end of an if block
:macro jmp_end DESTINATION_ADDRESS {
	jump DESTINATION_ADDRESS
	end
}

: validate_invalid
	0x00 0x00 0x22 0x14 0x08 0x14 0x22 0x00

: validate_valid
	0x00 0x00 0x25 0x55 0x56 0x55 0x25 0x00

: draw_guess_validity_marker
	# fast validity indicato
	draw_y -= GRID_TILE_HEIGHT

	i := chosen_code_valid
	load vF - vF
	if vF == 0 begin
		i := validate_invalid
	else
		i := validate_valid
	end
	sprite draw_x draw_y 8

	draw_y += GRID_TILE_HEIGHT

return


: handle_input
	:alias keypress a16_hi
	:alias target b16_hi
	:alias action b16_lo

	keypress := key
	action := 0 # action to apply

	# encapsulate repeated behavior quickly
	:macro keyhandle KEY_VALUE ACTION TARGET {
	if keypress == KEY_VALUE begin
		action := ACTION
		target := TARGET
		jump handle_action
	end
	}

	# register handling for a specific tumbler
	:macro tumbler_handler TUMBLER_ID DECREMENT_KEY INCREMENT_KEY {
	keyhandle DECREMENT_KEY DECREMENT TUMBLER_ID
	keyhandle INCREMENT_KEY INCREMENT TUMBLER_ID
	}


	keyhandle SUBMIT_KEY SUBMIT 0 # target doesn't actually get used, value irrelevant

	tumbler_handler 0 TUMBLER_0_DECREMENT TUMBLER_0_INCREMENT
	tumbler_handler 1 TUMBLER_1_DECREMENT TUMBLER_1_INCREMENT
	tumbler_handler 2 TUMBLER_2_DECREMENT TUMBLER_2_INCREMENT
	tumbler_handler 3 TUMBLER_3_DECREMENT TUMBLER_3_INCREMENT

	# we aren't drawing anything if an invalid key was pressed
	if action == 0 then return

	select_combo_to_render chosen_code

	:macro wait_until_buzzer DELAY BUZZER {
		vf := DELAY
		delay := vF
		vf := BUZZER
		buzzer := vF

		loop
			vF := delay
			while vf != 0
		again
	}

	: handle_action
	# submit the code, etc
	if action == SUBMIT begin

		# skip if pattern isn't valid
		i := chosen_code_valid
		load vF - vF
		if vF == 0 then jump _handle_input_end

		# move up one grid tile so we can place a judgement square
		draw_guess_validity_marker

		draw_square

		# restore, then advance the current draw position by a column
		draw_x += GRID_TILE_WIDTH
		save_draw_position

		# draw the new base column
		draw_guess_validity_marker
		draw_selected_combo

		# reset drawing position to original location

	#:breakpoint digit_change
	else # change the combination used
		:alias digit_temp a16_lo

		# erase the current combo and validity
		draw_guess_validity_marker
		draw_selected_combo

		i := chosen_code_value
		i += target
		load digit_temp - digit_temp

		#:breakpoint pre_change

		if action == DECREMENT begin
			if digit_temp == DIGIT_MIN begin
				digit_temp := DIGIT_MAX
			else
				digit_temp -= 1	 
			end	

		else # must be increment
			if digit_temp == DIGIT_MAX begin
				digit_temp := DIGIT_MIN	
			else
				digit_temp += 1
			end
		end

		save digit_temp - digit_temp
		#:breakpoint post_change


		validate_chosen_and_calculate_mask

		# redraw updated combo
		draw_guess_validity_marker
		draw_selected_combo

		# restore the cached combo start position
	end
	: _handle_input_end
return

: main
	# common setup
	hires

	: init
		genenerate_hidden_combo
		
		# set first combination draw position
		draw_x := GRID_START_LEFT
		draw_y := GRID_START_CHARS_TOP
		save_draw_position

		select_combo_to_render chosen_code
		draw_guess_validity_marker
		draw_selected_combo

		jump draw_stuff

	: loop_start

	#draw_y := GRID_START_TOP
	save_draw_position

	: draw_stuff
	handle_input


	# todo: can use screen spam of numbers to do a welcome screen effect

	jump loop_start
;